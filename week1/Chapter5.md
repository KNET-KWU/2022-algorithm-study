알고리즘의 정당성 증명
---

알고리즘의 정당성은 알고리즘이 문제를 제대로 해결하는지 파악하는 것입니다.

단위테스트를 이용해 여러 개의 입력에 대해 프로그램을 실행해보고 그 답을 점검해볼 수도 있지만,
모든 입력에 대해 증명이 불가합니다.

먼저, 단위 테스트는 모듈이나 애플리케이션 안에 있는 개별적인 코드 단위가 예상대로 작동하는지 확인하는 반복적인 행위입니다.

단위 테스트를 하는 이유는 내 코드가 제대로 동작하는지 확인하는 것 이라는 이유 외에도 
코드를 어떻게 작성하는지 생각하는데 도움을 주고 빠진 게 있는지 돌아 볼 수 있다는 장점이 있습니다.

단위 테스트를 하는 예시를 가져와 봤습니다.

[ 테스트 코드 작성 공통 규칙 ]

```
@DisplayName("로또 번호 갯수 테스트")
@Test       //해당 메소드가 단위 테스트임을 명시하는 어노테이션
void lottoNumberSizeTest() {
    // given

    // when

    // then
}
```

[ given/when/then 패턴 ]

given-when-then 패턴이란 1개의 단위 테스트를 3가지 단계로 나뉘는데,

given(준비): 어떠한 데이터가 준비되었을 때   
when(실행): 어떠한 함수를 실행하면    
then(검증): 어떠한 결과가 나와야 한다.

[ 로또 생성기 Java 코드 ]

예를 들어 다음과 같이 1000원을 주면 1개의 로또를 생성해주는 클래스가 있다고 하자.

```
public class LottoNumberGenerator {

    public List<Integer> generate(final int money) {
        if (!isValidMoney(money)) {
            throw new RuntimeException("올바른 금액이 아닙니다.");
        }
        return generate();
    }

    private boolean isValidMoney(final int money) {
        return money == 1000;
    }

    private List<Integer> generate() {
        return new Random()
                .ints(1, 45 + 1)
                .distinct()
                .limit(6)
                .boxed()
                .collect(Collectors.toList());
    }

}
```

이 로또 번호 생성기 코드에 대한 테스트 코드들을 작성해보면, 3가지를 작성할 수 있는데,

1. 로또 번호 갯수 테스트   

return 값으로 받은 로또가 6개인지 테스트하는 코드이다.

```

@DisplayName("로또 번호 갯수 테스트") 
@Test 
void lottoNumberSizeTest() {    
  // given    
  final LottoNumberGenerator lottoNumberGenerator = new LottoNumberGenerator();    
  final int price = 1000;  
  
  // when    
  final List<Integer> lottoNumber = lottoNumberGenerator.generate(price);    
  
  // then     
  assertThat(lotto.size()).isEqualTo(6); 
}

```

2. 로또 번호 범위 테스트  

로또번호가 1~45사이의 숫자인지를 테스트하는 코드이다.

```

@DisplayName("로또 번호 범위 테스트") 
@Test 
void lottoNumberRangeTest() {    
  // given    
  final LottoNumberGenerator lottoNumberGenerator = new LottoNumberGenerator();   
  final int price = 1000;    
  
  // when    
  final List<Integer> lotto = lottoNumberGenerator.generate(price);  
  
  // then    
  assertThat(lotto.stream().allMatch(v -> v >= 1 && v <= 45)).isTrue(); 
}

```

3. 잘못된 로또 금액 테스트   

예외처리가 잘 작동하는지 테스트하는 코드이다.

```

@DisplayName("잘못된 로또 금액 테스트")
@Test 
void lottoNumberInvalidMoneyTest() {    
  // given    
  final LottoNumberGenerator lottoNumberGenerator = new LottoNumberGenerator();    
  final int price = 2000;  
  
  // when    
  final RuntimeException exception = assertThrows(RuntimeException.class, () -> 
  lottoNumberGenerator.generate(price));  
  
  // then    
  assertThat(exception.getMessage()).isEqualTo("올바른 금액이 아닙니다."); 
}


```

이런 단위 테스트는 코드의 문제가 있음을 증명할 수는 있지만, 문제가 없음을 증명할 수 없다는 단점이 있습니다.

그러므로 이런 단점을 보완할 수 있는 방법들을 소개해 보겠습니다.

수학적 귀납법 
---

알고리즘은 반복적인 요소를 가지고 있으므로, 
수학적 귀납법은 알고리즘의 정당성을 증명할 때 가장 유용하게 사용되는 기법입니다.

수학적 귀납법을 사용하는 단계는 3단계로 나뉘는데, 도미노게임에 접목해서 설명해 보겠습니다.

1. 단계 나누기 : 증명하고 싶은 사실을 여러개로 나눈다.
ex) 100개의 도미노를 하나씩 나눈다

2. 첫 단계 증명 : 첫 단계에서 증명하고 싶은 내용이 성립함을 보인다.
ex) 첫 번쨰 도미노가 넘어짐을 증명

3. 귀납 증명 : 한 단계에서 증명하고 싶은 내용이 성립한다면, 다음 단계에서도 성립함을 보이기.
ex) 한 도미노가 쓰러지면, 다음 도미노도 반드시 쓰러짐

반복문 불변식
---

반복문 불변식이란, 반복문의 내용이 한 번 실행될 때마다 중간결과가 우리가 원하는 답으로 가는 길 위에 잘 있는지 명시하는 조건입니다.

불변식이 반복문 종료시에 항상 성립한다는 것을 보일 수 있다면, 알고리즘의 정당성은 증명한 것입니다.

불변식이 성립함을 보이는 예제입니다. (p.133 삽입 정렬 알고리즘)

```
void insertionSort(vector<int>& A) {
  for(int i = 0 ; i < A.size() ; ++i ) {
    //불변식 a : A[0...i-1]은 이미 정렬되어 있다.
    //A[0...i-1]에 A[i]를 끼워넣는다.
    int j = i;
    while(j > 0 && A[j-1] > A[j]) {
      //불변식 b : A[j+1...i]의 모든 원소는 A[j]보다 크다.
      //불변식 c : A[0...i]구간은 A[j]를 제외하면 정렬되어 있다.
      swap(A[j-1], A[j]);
      --j;
     }
   }
}
```

불변식(a)에 따르면 for문이 종료했을 때, A전체가 정렬된 상태가 됩니다. 그러므로, 불변식(a)가 항상 참임을 보여주면 됩니다.

초기 조건 : 반복문이 시작할 때 i=0이면 해당 구간은 비어 있으니 항상 정렬되어 있다고 가정할 수 있습니다.    
불변식 유지 : for문의 내용이 종료할 때 이 불변식이 깨지지 않고 유지됨을 보이기 위해서는 while문의 정당성을 증명해야 합니다

while문의 정당성은 불변식(b),(c)를 이용해 증명합니다. while문이 종료할 때 불변식 (b),(c)가 성립한다면 불변식(a)도
성립한다는 사실을 보이면 된다.

(b) 초기 조건 : while문 진입시에 A[j+1...i]구간은 빈 구간이므로 (b)는 참이다.        
(b) 유지 조건 : while문 내용이 실행되었다는 말은 A[j-1] > A[j] 라는 의미이니, 이 둘을 교체하고 j를 1줄이면 (b)는 여전히 참이 됩니다.

(c) 초기 조건 : 불변식 (a)에 의해 구간A[0...i-1]는 정렬되어 있으니 while문 진입시에 (c)는 항상 참입니다.        
(c) 유지 조건 : A[j]와 이전 원소를 교체한다고 해도 정렬된 것들의 상대적 순서는 변하지 않기 때문에 (c)또한 항상 유지됩니다.

따라서, 불변식 (a)의 유지 조건이 성립하므로 삽입 정렬이 배열을 정확하게 정렬한다고 말할 수 있습니다.

이렇게 불변식을 이용해 반복문의 정당성을 증명하는 것은, 귀납법과 유사하다고 봐도 될 것 같습니다.

위의 코드에서 주석처리 했던 부분을 assert 단정문을 이용해 불변식을 강제 할 수 있지만, 어느정도 속도에 지장을 주기 때문에,
많이 실행되는 반복문 안에 쓰는 것을 삼가하는 것이 좋습니다.


귀류법
---

귀류법이란, 어떤 명제가 참임을 증명하려 할 때 그 명제의 결론을 부정함으로써 가정 또는 공리 등이 모순됨을 보여 간접적으로 그 결론이 성립한다는 것을 증명하는 방법입니다
  
어떤 선택이 최선임을 증명할 떄 자주 쓰입니다. 더 좋은 답이 있다고 가정한 후에, 그런일은 있을 수 없다고 증명하는 방식을 사용합니다.

### 책장 쌓기

각 책장마다 버틸 수 있는 최대 무게 : M_i
자신의 무게 : W_i
i번째 책장위에 쌓인 모든 책장의 집합 : above(i)
A위에 올라가 있는 상자들의 무게의 합 : X
특정 책장 위에 올라간 다른 책장들의 무게의 합이 특정 책장이 버틸 수 있는 최대 무게를 초과하면 안된다고 가정합니다.

정답은 M_i + W_i 가 큰 것부터 아래에 놓아야 하는 것인데, 이것을 귀류법을 사용하여 증명해보면,

(먼저, 결론을 부정하고)    
위에서  M_i + W_i 가 큰 것부터 아래에 놓아야 한다고 했으니, 역으로 M_i + W_i가 더 큰 책장A가 더 작은 책장 B위에 올라간 형태라고 가정합니다.

이때, A와 B의 위치를 항상 바꿀 수 있음을 증명하면 됩니다. 
그러면 M_i + W_i 가 큰 것이 밑에 가도록 쌓으면 최선의 답을 얻을 수 있다는 것을 증명할 수 있습니다.

A가 B보다 더 큰 책장이라 했으므로,   
M_A + W_A > M_B + W_B 식이 성립하면, M_A  > M_B + W_B - W_A 식이 성립한다.    
가정에 의해, M_B >= W_A + X 이다.    
그러므로 M_A > X + W_B 식이 성립한다.   
그 말은, A도 B와 나머지 모든 상자들을 지탱할 수 있다는 말이다.    
따라서, 우리가 원하는 순서대로 쌓았을 때 가장 높은 탑을 얻지 못하는 경우는 존재하지 않는다는 것을 알 수 있다.


### 소수의 개수는 유한 개? 무한 개?

소수의 개수를 유한 개라 가정하자.

즉, 유한개의 소수를 다음과 같이 크기대로 나열한다.       
p1, p2, p3,  ... , pk

이제 자연수 N을 다음과 같이 정의한다.

N = (p1 * p2 * p3 * ... * pk) +1

이때, 자연수 N을 소수 p1으로 나누면 1이 남는다.      
즉, N은 소수 p1으로 나누어떨어지지 않는다.

또한, 자연수 N을 소수 p2으로 나누면 1이 남는다.      
즉, N은 소수 p2으로 나누어떨어지지 않는다.

마찬가지로, 자연수 N을 소수 pm으로 나누면 1이 남는다.       
즉, N은 소수 pm으로 나누어떨어지지 않는다. (m=1,2,3,...,k)

따라서 자연수 N은 모든 유한개의 소수 p1, p2, p3, ... , pk에 의해 나누어지지 않으므로 N은 소수이다.

이는 모든 소수가 p1, p2, p3, ... , pk라는 가정에 모순이다.      
따라서 가정이 거짓이므로 소수는 무한 개이다.


다른 기술들
---

### 비둘기집의 원리

10마리의 비둘기가 9개의 비둘기집에 모두 들어있다면, 2마리 이상이 들어간 비둘기집이 반드시 하나는 존재한다.

### 동전 뒤집기

100개의 동전 중에서 F개는 앞, 100-F개는 뒷면이 위로 놓여있다. 한 번 뒤집을 때 x개의 동전을 한꺼번에 뒤집어야 한다.   
이때 뒤집는 횟수를 최소화하고 싶을때, 답의 상한은 100번이다   
동전을 1번 뒤집을때마다 보이는 앞면의 개수를 적는다고 하면, 만약 101번을 뒤집었을 때 초기값인 F개도 포함해서 
102개의 숫자를 적게 되는데, 앞면의 개수는 0부터 100까지 101가지의 값만 가질 수 있으므로 비둘기집의 원리에 의해서 
중복이 발생하므로 101번은 최선의 답이 아니다.

### 순환 소수 찾기

분수 a/b가 주어질 때 실수 연산을 쓰지 않고 이 분수를 소수 형태로 출력하려 할 때의 코드를 보면,

```

//분수a/b의 소수 표현을 출력한다
//a>=0, b>0이라고 가정함
void printDecimal(int a, int b) {
    int iter = 0;
    while (a > 0) {
        //첫 번째와 두 번째 사이에 소수점을 찍는다
        if (iter++ == 1)
            cout << '.';
        cout << a / b;
        a = (a % b) * 10;
    }
}

```

 순환소수라면 무한루프에 걸리므로, 끊어줄 곳이 필요하다. a % b의 결과는 언제나 [0, b-1]의 범위의 값을 가지므로
 while문이 b+1번 반복될때까지 함수가 종료하지 않았으면, 비둘기집의 원리에 의해서 a % b의 결과는 b가지의 결과만 
 가질 수 있으니, 결과가 중복되는 부분이 있으므로, 같은 결과가 첫 번째 등장했을 때부터 두 번째 등장할때까지가 
 순환마디임을 알 수 있다.
 
 ### 구성적 증명
 
 구성적 증명은 우리가 원하는 어떤 답이 존재한다는 사실을 증명하기 위해 사용된다     
 '답이 존재하는가'에 대한 대답으로 '이렇게 만들면 된다'라고 하는 것      
 답의 존재성을 보이는 대신 답을 만드는 알고리즘을 제시함으로써 답이 존재함을 보입니다.
 
 예를 들어 하늘을 나는 교통수단을 만들 수 있다는 주장을 증명하려 할 떄,
 
 비구성적 증명은 양력의 법칙, 지구 공기의 밀도, 사용할 수 있는 재료들의 강도와 탄성들을 하나하나 열거해 가며 논리 전개하는 방식이고
 구성적 증명은 비행기를 만들어서 보여주거나, 비행기 만드는 법이 적힌 설명서를 제공하는 방식입니다.
 
